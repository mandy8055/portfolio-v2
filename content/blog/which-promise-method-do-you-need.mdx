---
title: 'Which promise method do you need?'
description: 'A deep dive into Promise.all, Promise.any, Promise.race, and Promise.allSettled â€” with polyfills, gotchas, and a decision framework to help you pick the right one.'
date: 2026-03-01
tags: ['javascript', 'web-development', 'async-programming']
---

Last week, a flatmate of mine â€” a seasoned Java/Spring backend developer â€” knocked on my door with a quick frontend question. He'd been handed a small task on the frontend side of his project, nothing major, and had reached out for a sanity check before pushing his code.

He had used `Promise.race` to implement a fallback â€” if the primary API failed, he wanted to use the backup. The logic made sense in his head. But the implementation was wrong, and the bug was subtle enough that it had slipped through his initial testing.

When I asked him _"do you know the difference between `race` and `any`?"_, he paused. And honestly? The pause made me think. Because two years ago, I would have paused too.

That conversation sent me down a rabbit hole â€” rebuilding polyfills for all four Promise methods â€” `all`, `any`, `race`, and `allSettled` â€” from scratch, just to make sure I truly understood the internals and not just the surface-level API.

Now, there are already separate blog posts floating around on each of these (including some I wrote a couple of years ago ğŸ˜„). But the real gap isn't understanding each method individually â€” it's knowing how they relate to each other and which one to reach for in a given situation.

So this is that blog where I wanted to share my learning. The consolidated one. The "one ring to rule them all" of Promise methods. ğŸ’

---

## The Quick Cheat Sheet (For the Impatient ğŸ˜„)

| Method               | Resolves when                    | Rejects when              | Returns                           |
| -------------------- | -------------------------------- | ------------------------- | --------------------------------- |
| `Promise.all`        | **All** resolve                  | **Any one** rejects       | Array of values (ordered)         |
| `Promise.any`        | **Any one** resolves             | **All** reject            | First resolved value              |
| `Promise.race`       | **Any one** settles              | **Any one** rejects first | First settled value               |
| `Promise.allSettled` | **All** settle (always resolves) | Never                     | Array of `{status, value/reason}` |

---

## The Decision Framework

Before the deep dive, here's the mental model I use when picking between these four:

> **Do you need ALL to succeed?** â†’ `Promise.all`
>
> **Do you need just ONE to succeed, ignoring the rest?** â†’ `Promise.any`
>
> **Do you want whoever finishes first â€” win or lose?** â†’ `Promise.race`
>
> **Do you want the full picture regardless of success or failure?** â†’ `Promise.allSettled`

If that's all you needed, you're welcome. ğŸ˜„ For everyone else, let's go deeper.

---

## [Promise.all](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)

### What it does

Takes an array of promises and returns a single promise that resolves with an **array of all resolved values**, in the same order as the input. If **any one promise rejects**, the whole thing rejects immediately â€” it doesn't wait for the rest.

```js
const promise1 = Promise.resolve('Hello');
const promise2 = Promise.resolve(42);
const promise3 = new Promise((resolve) => setTimeout(resolve, 100, 'World'));

Promise.all([promise1, promise2, promise3])
  .then((values) => console.log(values))
  .catch((error) => console.error(error));
// Output: ["Hello", 42, "World"]
```

### When to use it

- Fetching data from multiple APIs where **all results are required** to render (think dashboards)
- Uploading multiple files and waiting for all to complete before showing a success message
- Batch database operations where all must succeed together

### Polyfill

```js
function all(promises) {
  function executorFunction(resolve, reject) {
    const result = [];
    let pendingCount = promises.length;

    if (pendingCount === 0) {
      resolve(result);
      return;
    }

    promises.forEach((promise, index) => {
      Promise.resolve(promise).then((value) => {
        result[index] = value; // ğŸ‘ˆ index assignment, not push
        if (--pendingCount === 0) {
          resolve(result);
        }
      }, reject); // first rejection short-circuits everything
    });
  }
  return new Promise(executorFunction);
}
```

> **âš ï¸ The gotcha hiding in plain sight:** Notice I use `result[index] = value` and NOT `result.push(value)`. If I used `push`, the order would depend on which promise resolved first â€” not the original input order. `Promise.all` guarantees output order matches input order, and this one line is why. The `pendingCount` counter is how I know when every promise has settled without needing `await`.

---

## [Promise.any](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any)

### What it does

Returns a promise that resolves with the **first fulfilled value**. Rejections are silently ignored â€” unless _all_ promises reject, in which case it throws an [`AggregateError`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError) wrapping all the rejection reasons.

```js
const promise1 = Promise.reject(new Error('First failed'));
const promise2 = new Promise((resolve) => setTimeout(resolve, 100, 'Success'));
const promise3 = Promise.reject(new Error('Second failed'));

Promise.any([promise1, promise2, promise3])
  .then((value) => console.log(value))
  .catch((error) => console.error(error));
// Output: "Success"
```

### When to use it

- Trying multiple CDN sources and using whichever responds first
- Primary + backup service pattern â€” use the backup only if primary fails
- Optimistic UI â€” show cached data or fresh API data, whoever arrives first wins

### Polyfill

```js
function any(promises) {
  function executorFunction(resolve, reject) {
    const errors = [];
    let pendingCount = promises.length;
    if (pendingCount === 0) {
      reject(new AggregateError(errors, 'No promises were passed'));
      return;
    }

    promises.forEach((promise, idx) => {
      Promise.resolve(promise)
        .then((val) => resolve(val)) // first resolve wins
        .catch((err) => {
          errors[idx] = err; // preserve order of errors
          if (--pendingCount === 0) {
            reject(new AggregateError(errors, 'All promises were rejected'));
          }
        });
    });
  }
  return new Promise(executorFunction);
}
```

> **âš ï¸ Two gotchas here:**
>
> **Gotcha 1 â€” AggregateError is not a regular Error:** When all promises reject, the catch block receives an `AggregateError`. Don't try to read `error.message` expecting individual reasons â€” access `error.errors` (the array) to get each rejection reason.
>
> **Gotcha 2 â€” Empty array behavior:** `Promise.any([])` immediately rejects with `AggregateError`. This is the _opposite_ of `Promise.all([])`, which immediately _resolves_ with an empty array. Catch this during interviews â€” it's a classic trap. ğŸ˜„

Notice the symmetry with the `Promise.all` polyfill â€” but inverted. In `all`, a single rejection short-circuits. In `any`, a single resolution short-circuits. We still use indexed assignment for errors (not push) so the error order matches the input order, which matters when you're debugging why everything blew up.

---

## [Promise.race](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)

### What it does

Returns a promise that settles as soon as the **first promise settles** â€” resolve _or_ reject. Whoever finishes first, wins. The others are abandoned.

```js
const promise1 = new Promise((resolve) => setTimeout(resolve, 200, 'Slow'));
const promise2 = new Promise((resolve) => setTimeout(resolve, 100, 'Fast'));

Promise.race([promise1, promise2])
  .then((value) => console.log(value))
  .catch((error) => console.error(error));
// Output: "Fast"
```

### When to use it

The classic use case â€” implementing a timeout for any async operation:

```js
const fetchData = () => fetch('https://api.example.com/data');

const timeout = (ms) =>
  new Promise((_, reject) =>
    setTimeout(() => reject(new Error('Request timed out')), ms),
  );

Promise.race([fetchData(), timeout(5000)])
  .then((response) => response.json())
  .catch((error) => console.error(error));
// Rejects with "Request timed out" if API doesn't respond in 5 seconds
```

### Polyfill

```js
function race(promises) {
  function executorFunction(resolve, reject) {
    for (const promise of promises) {
      Promise.resolve(promise).then(resolve, reject);
    }
  }
  return new Promise(executorFunction);
}
```

This is the simplest polyfill of the four â€” and the elegance is worth appreciating. Once a Promise settles, subsequent calls to `resolve` or `reject` are silently ignored by the JS engine. So we just attach handlers to every promise and let the first one win naturally. No counter, no result array, no complexity.

> **âš ï¸ The race vs any confusion:** This is the most common mixup I see.
>
> - `race` = first to **finish** (resolve OR reject). A rejection wins the race too.
> - `any` = first to **succeed**. Rejections are ignored until all fail.
>
> If the first promise to settle in `Promise.race` is a rejection, the whole thing rejects â€” it doesn't wait for a successful one. If that's not what you want, you probably want `Promise.any`.

> **âš ï¸ Empty array is a silent trap:** `Promise.race([])` returns a promise that is permanently pending â€” it never settles. Unlike `Promise.all([])` which resolves immediately, or `Promise.any([])` which rejects immediately, `race` just waits forever. Always guard against this in production code:
>
> ```js
> if (promises.length === 0)
>   return Promise.reject(new Error('No promises provided'));
> ```

---

## [Promise.allSettled](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled)

### What it does

Waits for **all promises to settle** and returns an array of objects describing each outcome. It **never rejects** â€” you always get the full picture, wins and losses both.

```js
const promise1 = Promise.resolve('Hello');
const promise2 = Promise.reject(new Error('Something went wrong'));
const promise3 = new Promise((resolve) => setTimeout(resolve, 100, 'World'));

Promise.allSettled([promise1, promise2, promise3]).then((results) =>
  console.log(results),
);
// Output:
// [
//   { status: "fulfilled", value: "Hello" },
//   { status: "rejected", reason: Error: Something went wrong },
//   { status: "fulfilled", value: "World" }
// ]
```

### When to use it

- Fetching from multiple APIs where **partial success is acceptable** â€” show what you have, log what failed
- Batch processing where some failures are expected and shouldn't stop the rest
- Running multiple independent operations and reporting the full outcome

### Polyfill

```js
function allSettled(promises) {
  function executorFunction(resolve) {
    // â˜ï¸ no reject parameter â€” we always resolve
    const result = [];
    let pendingCount = promises.length;

    if (pendingCount === 0) {
      resolve(result);
      return;
    }

    promises.forEach((promise, idx) => {
      Promise.resolve(promise)
        .then((value) => (result[idx] = { status: 'fulfilled', value }))
        .catch((reason) => (result[idx] = { status: 'rejected', reason }))
        .finally(() => {
          if (--pendingCount === 0) {
            resolve(result);
          }
        });
    });
  }
  return new Promise(executorFunction);
}
```

> **âš ï¸ Implementation insight:** The executor function deliberately omits the `reject` parameter â€” this promise should never reject, so why even have it there? The `.finally()` is the cleanest way to decrement the counter regardless of whether `.then` or `.catch` ran. Both write to `result[idx]` before `.finally` fires, so by the time we call `resolve`, every slot is already filled.

---

## The Side-by-Side That Makes It Click

Let me pass the same promises to all four and you'll immediately see the difference:

```js
const fast = Promise.resolve('fast');
const slow = new Promise((res) => setTimeout(res, 200, 'slow'));
const fail = Promise.reject(new Error('failed'));

// Promise.all â€” one failure, everything fails
Promise.all([fast, slow, fail]);
// âŒ Rejects with Error: "failed"

// Promise.any â€” one success is enough
Promise.any([fast, slow, fail]);
// âœ… Resolves with "fast"

// Promise.race â€” fail settles first (it's already rejected)
Promise.race([fail, fast, slow]);
// âŒ Rejects with Error: "failed"

// Promise.allSettled â€” never rejects, full picture
Promise.allSettled([fast, slow, fail]);
// âœ… Resolves with:
// [
//   { status: 'fulfilled', value: 'fast' },
//   { status: 'fulfilled', value: 'slow' },
//   { status: 'rejected', reason: Error: 'failed' }
// ]
```

---

## Common Mistakes (That I've Also Made ğŸ˜…)

**1. Reaching for `Promise.all` when partial failure is fine**

If your dashboard can render with 3 out of 4 APIs responding, use `allSettled` and handle failures individually. `Promise.all` will discard all results the moment one fails. Most real-world scenarios are more forgiving than `Promise.all` assumes.

**2. Confusing `race` and `any`**

`race` = first to _finish_. `any` = first to _succeed_. If you want a timeout that only triggers when your request actually fails (not just when it's slower than a competing promise), you want `any` not `race`.

**3. Forgetting `AggregateError` in `Promise.any`**

Your catch block for `Promise.any` will receive an `AggregateError` when all promises reject. Accessing `error.message` won't give you the individual reasons. You need `error.errors` â€” the array of all rejection reasons.

**4. Using `push` instead of index assignment in custom implementations**

If you ever write a custom aggregator and use `result.push(value)` instead of `result[index] = value`, you'll silently break the order guarantee. The output order will depend on resolution speed, not input order. And this will only show up in production under load. Fun times. ğŸ˜„

---

## Quick Reference

| Method               | Use when...                                                  |
| -------------------- | ------------------------------------------------------------ |
| `Promise.all`        | You need ALL results and one failure should abort everything |
| `Promise.any`        | You need ONE success and don't care which one                |
| `Promise.race`       | You want the first to settle â€” success or failure            |
| `Promise.allSettled` | You want all outcomes and will handle each individually      |

---

Building these polyfills from scratch was genuinely one of the better learning exercises I've done recently. Reading docs tells you _what_ these methods do. Writing the internals tells you _why_ they behave the way they do â€” and that's where the real understanding lives.

Until next time, Pranipat ğŸ™!
